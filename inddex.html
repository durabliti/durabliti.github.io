<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Universal Multiplayer & Server-Authoritative Physics Specification</title>

<style>
:root {
  --bg:#0f1116;
  --panel:#151823;
  --text:#e6e6e6;
  --muted:#9aa0aa;
  --accent:#4da6ff;
  --border:#23273a;
  --code:#0b0d14;
}

* {
  box-sizing:border-box;
  font-family:system-ui,Segoe UI,Arial,sans-serif;
}

html { scroll-behavior:smooth; }

body {
  margin:0;
  display:flex;
  background:var(--bg);
  color:var(--text);
}

nav {
  width:300px;
  height:100vh;
  position:fixed;
  padding:20px;
  background:var(--panel);
  border-right:1px solid var(--border);
  overflow:auto;
}

nav h1 {
  font-size:18px;
  margin-bottom:10px;
}

nav a {
  display:block;
  color:var(--text);
  text-decoration:none;
  padding:6px 0;
  font-size:14px;
}

nav a:hover { color:var(--accent); }

main {
  margin-left:300px;
  padding:40px;
  max-width:1100px;
}

section { margin-bottom:90px; }

h2 {
  border-bottom:1px solid var(--border);
  padding-bottom:6px;
  margin-top:60px;
}

h3 { margin-top:40px; }

p {
  line-height:1.8;
  color:var(--muted);
}

pre {
  background:var(--code);
  padding:16px;
  border-radius:6px;
  overflow:auto;
  font-size:14px;
}

table {
  width:100%;
  border-collapse:collapse;
  margin-top:20px;
}

th,td {
  border:1px solid var(--border);
  padding:8px;
}

th { background:var(--panel); }

.note {
  border-left:4px solid var(--accent);
  padding:14px;
  margin:25px 0;
  background:var(--panel);
}
</style>
</head>

<body>

<nav>
<h1>Multiplayer Spec</h1>
<a href="#intro">Введение</a>
<a href="#philosophy">Философия</a>
<a href="#architecture">Архитектура</a>
<a href="#threat">Модель угроз</a>
<a href="#protocol">Протокол</a>
<a href="#physics">Server-side Physics</a>
<a href="#movement">Перемещение</a>
<a href="#collision">Коллизии</a>
<a href="#sync">Синхронизация</a>
<a href="#security">Безопасность</a>
<a href="#examples">Код</a>
</nav>

<main>

<section id="intro">
<h2>Введение</h2>
<p>
Этот документ описывает универсальную архитектуру мультиплеера,
в которой сервер является единственным авторитетом над состоянием мира,
включая физику, столкновения, скорость, гравитацию и взаимодействия.
</p>
<p>
Документация предназначена для разработчиков игр, симуляторов и
realtime-приложений, где критичны целостность данных, защита от читинга
и предсказуемость поведения системы.
</p>
</section>

<section id="philosophy">
<h2>Философия системы</h2>
<p>
Клиент никогда не считается доверенной стороной.
Любые данные, полученные от клиента, трактуются как намерения,
а не как фактическое изменение состояния.
</p>
<p>
Сервер:
</p>
<ul>
<li>обрабатывает ввод</li>
<li>рассчитывает физику</li>
<li>разрешает коллизии</li>
<li>публикует итоговое состояние</li>
</ul>

<div class="note">
Если клиент управляет физикой — это не мультиплеер, а симуляция доверия.
</div>
</section>

<section id="architecture">
<h2>Архитектура</h2>
<pre>
Client → Input → RPC → Server
Server → Physics → State → Client
</pre>

<p>
Клиент отправляет только ввод: направления, кнопки, намерения.
Ни позиция, ни скорость, ни столкновения не принимаются от клиента.
</p>
</section>

<section id="threat">
<h2>Модель угроз</h2>
<p>
Система проектируется с учётом того, что клиент может:
</p>
<ul>
<li>подделывать пакеты</li>
<li>ускорять время</li>
<li>отправлять невозможные значения</li>
<li>модифицировать память</li>
</ul>

<p>
Поэтому сервер обязан проверять:
</p>
<ul>
<li>длину векторов</li>
<li>частоту RPC</li>
<li>физическую достижимость действий</li>
</ul>
</section>

<section id="protocol">
<h2>Протокол сообщений</h2>
<pre>
{
  "type": "rpc | state | error",
  "clientId": 12,
  "tick": 102334,
  "payload": {}
}
</pre>

<p>
Tick используется для синхронизации симуляции
и предотвращения рассинхронизации.
</p>
</section>

<section id="physics">
<h2>Server-side Physics</h2>
<p>
Вся физика рассчитывается исключительно на сервере.
Это включает:
</p>
<ul>
<li>гравитацию</li>
<li>ускорение</li>
<li>трение</li>
<li>столкновения</li>
<li>ограничения скорости</li>
</ul>

<p>
Клиенту запрещено отправлять:
</p>
<ul>
<li>позицию</li>
<li>скорость</li>
<li>результаты коллизий</li>
</ul>

<div class="note">
Клиент отправляет только ввод, сервер решает результат.
</div>
</section>

<section id="movement">
<h2>Перемещение (Server authoritative)</h2>

<p>
Клиент отправляет направление движения.
Сервер применяет силу, учитывая физические ограничения.
</p>

<pre>
// Псевдокод сервера
function applyMovement(player, inputDir, dt) {
  if (length(inputDir) > 1)
    reject(player)

  acceleration = normalize(inputDir) * player.accel
  player.velocity += acceleration * dt

  if (length(player.velocity) > player.maxSpeed)
    player.velocity = normalize(player.velocity) * player.maxSpeed
}
</pre>

</section>

<section id="collision">
<h2>Коллизии</h2>
<p>
Коллизии вычисляются только сервером.
Клиент не может заявлять о попадании или столкновении.
</p>

<pre>
function resolveCollision(entity, world) {
  if (world.intersects(entity.bounds)) {
    entity.position = entity.lastSafePosition
    entity.velocity = vec3(0,0,0)
  }
}
</pre>
</section>

<section id="sync">
<h2>Синхронизация</h2>
<p>
Сервер отправляет:
</p>
<ul>
<li>позицию</li>
<li>скорость</li>
<li>состояние</li>
</ul>

<p>
Клиент:
</p>
<ul>
<li>интерполирует</li>
<li>визуализирует</li>
<li>корректирует расхождения</li>
</ul>
</section>

<section id="security">
<h2>Безопасность</h2>
<p>
Минимальные требования:
</p>
<ul>
<li>rate limit RPC</li>
<li>серверные таймеры</li>
<li>проверка расстояний</li>
<li>серверные cooldown</li>
</ul>

<div class="note">
Если действие невозможно физически — оно отклоняется.
</div>
</section>

<section id="examples">
<h2>Пример серверного цикла</h2>

<pre>
// Server tick loop
function serverTick(dt) {
  for (player of players) {
    applyMovement(player, player.input, dt)
    resolveCollision(player, world)
    integrate(player, dt)
  }
  broadcastState()
}
</pre>

<p>
Этот цикл является сердцем серверной симуляции
и не имеет клиентских аналогов.
</p>
</section>

</main>
</body>
</html>
